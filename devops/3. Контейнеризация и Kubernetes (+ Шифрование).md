Принято. Это отличный блок, потому что на собеседованиях часто ловят на путанице между «зашифровать» (encrypt) и «закодировать» (encode).

Добавим этот блок в раздел **III (или как смежный к безопасности)** и перейдем к ответам по контейнеризации и базе данных K8s.

---

# Раздел III: Контейнеризация и Kubernetes (+ Шифрование)

## 1. Encoding vs Encryption vs Hashing

Это база безопасности, которую DevOps должен знать «на зубок», чтобы не хранить пароли в Base64.

* **Encoding (Кодирование):** Преобразование данных в другой формат для передачи (например, бинарный файл в текст). **Это не защита!**
* *Пример:* **Base64** (используется в K8s Secrets). Его можно "расшифровать" одной командой без ключа.


* **Encryption (Шифрование):** Защита данных с помощью ключа. Бывает двух видов:
* **Симметричное (AES):** Один ключ и для шифрования, и для расшифровки. Быстро, для больших данных.
* **Асимметричное (RSA, ECDSA):** Пара ключей — Public (замок) и Private (ключ). Публичным шифруем, приватным расшифровываем. Основа TLS/HTTPS.


* **Hashing (Хеширование):** Необратимое преобразование данных в строку фиксированной длины. Нельзя «расхешировать» обратно.
* *Пример:* **SHA-256**, **bcrypt**. Используется для проверки целостности файлов или хранения паролей в БД.



---

## 2. Docker: Под капотом

* **Что такое контейнер:** Это изолированный процесс. Он использует ядро хоста (в отличие от VM, где свое ядро). Изоляция достигается через **Namespaces** (что вижу) и **Cgroups** (сколько ресурсов потребляю).
* **Слои (Layers):** Образ — это пирог из read-only слоев. Когда мы запускаем контейнер, сверху добавляется тонкий слой **Writable Layer**. Все изменения пишутся туда (Copy-on-Write).
* **Multi-stage Build:** Практика, когда в одном Dockerfile мы сначала собираем приложение (нужны компиляторы, SDK), а потом копируем только готовый бинарник в чистый, маленький образ (Alpine/Distroless). Это уменьшает размер и дыры в безопасности.

---

## 3. Kubernetes: Архитектура (Control Plane)

Если эти компоненты упадут — кластер перестанет управляться, но запущенные поды продолжат работать.

* **etcd:** Распределенное хранилище «ключ-значение». Единственный источник правды о состоянии кластера.
* **API Server:** «Лицо» K8s. Все (kubectl, компоненты) общаются только с ним по REST.
* **Scheduler:** Выбирает, на какую ноду приземлить под (смотрит на ресурсы, Affinity, Taints).
* **Controller Manager:** Следит за тем, чтобы «желаемое» состояние совпадало с «реальным» (например, если упал под — создать новый).

---

## 4. Жизненный цикл и Пробы Пода

* **Pause Container:** Невидимый контейнер в каждом поде. Он "держит" сетевой стек (IP) и Namespaces, чтобы основные контейнеры могли перезапускаться, не теряя сеть.
* **Health Checks:**
1. **Liveness:** "Ты живой?". Если нет — K8s убьет и перезапустит под.
2. **Readiness:** "Ты готов принимать трафик?". Если нет — под уберут из балансировщика (Service).
3. **Startup:** Для тяжелых приложений, которые долго грузятся. Пока она не пройдет, остальные пробы не начнутся.



---

## 5. Сети в K8s: Services и Kube-proxy

* **ClusterIP:** Внутренний IP пода, доступен только внутри кластера.
* **NodePort:** Пробрасывает порт на всех железных нодах (порт 30000-32767).
* **LoadBalancer:** Создает внешний балансировщик у облачного провайдера (AWS/GCP).
* **Kube-proxy:** Агент на каждой ноде. Он правит правила `iptables` или `IPVS`, чтобы трафик на IP сервиса попадал в нужный под.

---

## 6. Хранение данных (Storage)

* **PV (Persistent Volume):** Кусок диска, выделенный админом.
* **PVC (Claim):** Запрос от разработчика: "Мне нужно 10ГБ диска". K8s сам найдет подходящий PV и «подружит» их (Binding).
* **StorageClass:** Позволяет создавать диски динамически (Cloud Bursting).

---

## Команды для диагностики (K8s Troubleshooting)

| Задача | Команда |
| --- | --- |
| Почему под не стартует? | `kubectl describe pod <name>` (смотрим Events) |
| Посмотреть логи упавшего контейнера | `kubectl logs <name> --previous` |
| Выполнить команду внутри пода | `kubectl exec -it <name> -- bash` |
| Посмотреть нагрузку на ноды | `kubectl top nodes` (нужен Metrics Server) |
| Проверить права (RBAC) | `kubectl auth can-i create deployments` |
| Сменить контекст (кластер) | `kubectl config use-context <name>` |
| Декодировать секрет | `kubectl get secret my-secret -o jsonpath='{.data.password}' | base64 -d` |

---

### Твой ответ на вопрос «Как работает K8s?» должен звучать так:

> «Это система, основанная на **Control Loop** (цикле управления). Мы описываем в YAML желаемое состояние, API-server записывает его в etcd, а контроллеры постоянно работают над тем, чтобы реальность в кластере соответствовала этому описанию».

**Следующий этап — Раздел IV: IaC (Terraform, Ansible)? Или разберем подробнее, как работает алгоритм Raft в etcd?**