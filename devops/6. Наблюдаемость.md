# Раздел VI: Observability (Наблюдаемость)

## 1. Prometheus: Внутреннее устройство и TSDB

Prometheus — это не просто база данных, это система, оптимизированная под **временные ряды (Time Series)**.

* **TSDB (Time Series Database):** Это тип базы данных, где данные хранятся как последовательность значений с метками времени.
* **Как хранятся данные:**
* **In-Memory:** Свежие данные (последние пару часов) хранятся в оперативной памяти для мгновенного доступа.
* **WAL (Write-Ahead Log):** Каждая запись сначала попадает в лог на диске. Если Prometheus упадет, он восстановит данные из WAL.
* **Chunks:** Каждые 2 часа данные "замораживаются" в неизменяемые блоки (chunks) на диске.


* **Сжатие:** TSDB использует алгоритм **Facebook Gorilla**. Он позволяет сжимать данные так эффективно, что одна точка (время + значение) занимает в среднем всего **1.37 байта**.
* **Cardinality (Кардинальность):** Это количество уникальных комбинаций меток (labels). Если ты добавишь в метрику `user_id`, где миллион пользователей, Prometheus "съест" всю память и упадет, так как для каждой комбинации меток он создает отдельный временной ряд.

---

## 2. Grafana Loki: "Prometheus для логов"

Loki — это система сбора логов, вдохновленная Prometheus.

* **В чем фишка:** В отличие от Elasticsearch, Loki **не индексирует текст логов**. Он индексирует только те же метки (labels), что и Prometheus (например, `app="nginx", env="prod"`).
* **Почему это круто:** * **Дешевизна:** Loki потребляет в 10 раз меньше памяти и диска, чем ELK.
* **Скорость:** Поиск по меткам происходит мгновенно. Поиск по тексту (grep) идет перебором, но благодаря распределенной архитектуре это всё равно быстро.
* **Единый интерфейс:** В Grafana ты можешь нажать одну кнопку и переключиться с графика метрик на соответствующие им логи, так как у них одинаковые метки.



**Компоненты Loki (стек PLG):**

1. **Promtail:** Агент (DaemonSet), который бегает по нодам K8s, читает файлы логов и отправляет их в Loki.
2. **Loki:** Центральный сервер, который хранит данные.
3. **Grafana:** Визуализатор.

---

## 3. Pull vs Push модель

* **Pull (Prometheus):** Сервер сам ходит к приложениям по расписанию и забирает метрики.
* *Плюс:* Сервер контролирует нагрузку. Если приложение "спамит" метриками, сервер просто не заберет лишнего.


* **Push (Loki / InfluxDB):** Приложение само отправляет данные серверу.
* *Плюс:* Удобно для кратковременных задач (Job), которые умирают до того, как Prometheus успеет к ним прийти. Для этого в Prometheus используют **Pushgateway**.



---

## 4. Метрики: Counter, Gauge, Histogram

* **Counter (Счетчик):** Число, которое только растет (количество запросов, ошибок). Если сервер перезагрузится, он сбросится в 0. Используется с функцией `rate()`.
* **Gauge (Датчик):** Число, которое может и расти, и падать (загрузка памяти, количество подов, температура).
* **Histogram:** Разбивает данные по "корзинам" (buckets). Нужно для вычисления **квантилей** (например: "99% запросов выполняются быстрее, чем 200мс").

---

## 5. Практика: PromQL и LogQL

На собеседовании могут попросить написать запрос.

* **PromQL (Метрики):** `rate(http_requests_total{status="500"}[5m])` — среднее количество ошибок в секунду за последние 5 минут.
* **LogQL (Логи в Loki):** `{app="nginx"} |= "error" | json` — выбрать логи приложения nginx, отфильтровать по слову "error" и распарсить как JSON.

---

## 6. SRE-база: SLI, SLO, SLA

* **SLI (Indicator):** Что мы измеряем? (Например: "% успешных запросов").
* **SLO (Objective):** Цель, которую мы хотим достичь. (Например: "99.9% запросов должны быть успешными").
* **SLA (Agreement):** Юридический документ. Что будет, если мы не выполним SLO? (Например: "Вернем деньги клиенту").
* **Error Budget:** Время, которое нам *разрешено* лежать. Для 99.9% это ~43 минуты в месяц. Если бюджет кончился — замораживаем деплои и чиним стабильность.

---

### Твой Troubleshooting план:

1. **Grafana:** Видим на графике всплеск 500-х ошибок (Метрики).
2. **Explore (Loki):** Переходим в логи по тем же меткам времени и пода.
3. **Log Analysis:** Видим Stacktrace ошибки в JSON-логе.
4. **Fix:** Понимаем причину и катим фикс.

**Готов к последнему большому блоку — Раздел VII: Системный дизайн и Архитектура? Там обсудим, как склеить всё это в надежную систему.**