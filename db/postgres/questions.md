### Часть 1. Транзакции и ACID (Фундамент)

#### 1. Что такое ACID? Расшифруй и объясни каждый пункт.

Это гарантии надежности транзакций.

* **A — Atomicity (Атомарность):** Транзакция выполняется целиком или не выполняется вовсе ("Все или ничего"). Если упала ошибка на середине, база откатывает (Rollback) все изменения через *Undo Log*.
* **C — Consistency (Согласованность):** Транзакция переводит базу из одного валидного состояния в другое. Нарушать `Constraints` (Foreign Key, Unique, Check) нельзя.
* **I — Isolation (Изолированность):** Параллельные транзакции не должны мешать друг другу (видеть промежуточные результаты). Решается уровнями изоляции.
* **D — Durability (Долговечность):** Если база сказала `COMMIT`, данные сохранены на диске, даже если сервер тут же выключат. Обеспечивается через *WAL (Write Ahead Log)*.

#### 2. Какие существуют уровни изоляции транзакций и какие проблемы они решают?

Чем выше уровень, тем медленнее работает база.

1. **Read Uncommitted:** Видно незакомиченные данные. Проблема: *Dirty Read* (читаем данные, которые потом могут откатиться).
2. **Read Committed (Default в PG):** Видно только закомиченные данные. Проблема: *Non-repeatable Read* (читаем строку дважды в одной транзакции, а она изменилась между чтениями).
3. **Repeatable Read (Default в MySQL):** Снимок данных на момент начала транзакции. Строки не меняются. Проблема: *Phantom Read* (между выборками кто-то добавил новые строки, подходящие под условие).
4. **Serializable:** Строгая очередь. Полная имитация последовательного выполнения. Защищает от всего, но медленно и часто падает с ошибками сериализации.

#### 3. Что произойдет, если две транзакции одновременно попытаются изменить одну строку?

Произойдет **блокировка (Locking)**.

1. Первая транзакция ставит на строку эксклюзивную блокировку (`Row Exclusive Lock`), записывая свой ID в заголовок строки (`xmax`).
2. Вторая транзакция видит блокировку и **зависает** (впадает в ожидание), пока первая не сделает `COMMIT` или `ROLLBACK`.
3. Если первая сделала Commit, вторая транзакция либо перечитывает строку (Read Committed), либо падает с ошибкой (Repeatable Read).

---

### Часть 2. Внутреннее устройство (PostgreSQL Internals)

#### 4. Что такое MVCC и зачем оно нужно?

**Multi-Version Concurrency Control** — управление конкурентным доступом через многоверсионность.

* **Суть:** Читатели не блокируют писателей, а писатели не блокируют читателей.
* **Механизм:** Когда строка обновляется (`UPDATE`), Postgres не перезаписывает её, а создает **новую версию** рядом. Старая версия остается для тех транзакций, которые начались раньше.
* **Результат:** В базе могут одновременно жить 10 версий одной и той же строки для разных пользователей.

#### 5. Зачем нужен процесс VACUUM?

Из-за MVCC старые версии строк ("мертвые кортежи" или dead tuples) остаются на диске после удаления или обновления.
**VACUUM** — это сборщик мусора. Он проходит по таблицам, находит мертвые строки и помечает место как свободное, чтобы туда можно было записать новые данные. Без него база раздуется (Bloat).

#### 6. Что такое WAL (Write Ahead Log)?

Журнал предзаписи.

* **Правило:** "Сначала запиши в журнал, только потом меняй данные в таблице".
* **Зачем:** Запись в таблицу — это медленный случайный доступ (Random I/O). Запись в журнал — это быстрое добавление в конец файла (Sequential I/O).
* Если сервер упадет, при рестарте Postgres прочитает WAL и восстановит все, что не успело записаться в файлы данных.

#### 7. Почему `COUNT(*)` в PostgreSQL работает медленно?

В отличие от MySQL MyISAM (где число строк хранится в метаданных), Postgres из-за **MVCC** не знает точное число "живых" строк прямо сейчас. Ему нужно сделать **Full Scan** (прочитать всю таблицу) и проверить видимость каждой строки для текущей транзакции.

---

### Часть 3. Индексы и Оптимизация

#### 8. Как устроен B-Tree индекс?

Это сбалансированное дерево.

* **Корень и ветви** содержат диапазоны значений и навигацию.
* **Листья** содержат упорядоченные ключи и ссылки на строки в таблице (`TID`).
* Сложность поиска: **O(log N)**. Идеально для `=`, `>`, `<`, `BETWEEN`, `ORDER BY`.

#### 9. Кластеризованный vs Некластеризованный индекс?

* **Кластеризованный:** Данные таблицы физически отсортированы на диске по этому индексу. Лист индекса = сама строка данных. (Обычно это Primary Key в MySQL InnoDB).
* **Некластеризованный (Вторичный):** Отдельная структура. Лист индекса содержит ссылку (адрес) на данные в куче (Heap). Требует дополнительного чтения (Lookup).

#### 10. Что такое "Покрывающий индекс" (Covering Index)?

Ситуация, когда все данные, нужные для запроса, **уже лежат в самом индексе**.

* *Запрос:* `SELECT name FROM users WHERE age = 20`.
* *Индекс:* `(age, name)`.
* *Результат:* База находит `age=20`, сразу берет `name` и отдает ответ. **Чтения основной таблицы не происходит**. Это работает очень быстро (Index Only Scan).

#### 11. Что такое правило "Левого префикса" (Leftmost Prefix)?

Для составного индекса `(A, B, C)` порядок важен.

* Поиск по `A` — Ок.
* Поиск по `A` и `B` — Ок.
* Поиск только по `B` — **Не работает** (индекс бесполезен).
* *Аналогия:* В телефонной книге (Фамилия, Имя) нельзя найти всех "Алексеев", не зная фамилии.

#### 12. Почему UUID плох для Primary Key (с точки зрения производительности)?

UUID — это случайные 16 байт.

1. **Размер:** Занимает в 2-4 раза больше места, чем `INT`.
2. **Фрагментация:** При вставке случайного UUID в B-Tree индекс, он попадает в случайное место. Приходится постоянно разбивать страницы и перебалансировать дерево. Это убивает кэш и замедляет запись (Random I/O).

---

### Часть 4. Архитектура и Масштабирование

#### 13. Партиционирование vs Шардирование?

* **Партиционирование:** Деление большой таблицы на части **на одном сервере** (логическое деление). Пример: таблица `orders` делится на `orders_2023`, `orders_2024`. Ускоряет удаление старых данных и чтение диапазонов.
* **Шардирование:** Деление данных **между разными физическими серверами**. Пример: пользователи А-К на Сервере 1, Л-Я на Сервере 2. Используется для горизонтального масштабирования (когда 1 сервер не справляется).

#### 14. Синхронная vs Асинхронная репликация?

* **Асинхронная:** Мастер ответил "ОК" клиенту сразу, а на реплику отправил данные в фоне. Быстро, но при сбое мастера можно потерять данные.
* **Синхронная:** Мастер не отвечает "ОК", пока реплика не подтвердит запись. Данные не теряются (RPO=0), но запись медленнее, и если реплика упадет — мастер встанет.

#### 15. Что такое RPO и RTO?

* **RPO (Recovery Point Objective):** Сколько данных мы готовы потерять? (RPO=0 — ни байта не потеряно).
* **RTO (Recovery Time Objective):** Сколько времени сервис может лежать? (RTO=5 минут — через 5 минут все должно заработать).

#### 16. OLTP vs OLAP (Postgres vs ClickHouse)?

* **OLTP (Row-based):** Хранит данные строками. Быстро для точечных изменений, транзакций, вставки по одной строке. (Postgres, MySQL).
* **OLAP (Columnar):** Хранит данные колонками. При чтении "средней зарплаты" читает только файл с зарплатами, игнорируя остальные терабайты данных. Сжимает данные в 10 раз лучше. Плохо переносит частые `UPDATE` одиночных строк. (ClickHouse).

---

### Часть 5. Практические вопросы (SQL)

#### 17. Разница между `UNION` и `UNION ALL`?

* `UNION`: Объединяет выборки и **удаляет дубликаты**. Это дорогая операция (требует сортировки).
* `UNION ALL`: Просто склеивает результаты. Дубликаты остаются. Работает намного быстрее.

#### 18. В чем разница между `WHERE` и `HAVING`?

* `WHERE`: Фильтрует строки **ДО** группировки.
* `HAVING`: Фильтрует результаты **ПОСЛЕ** группировки (`GROUP BY`).

#### 19. Что такое N+1 проблема?

Ситуация в ORM (Hibernate, Django, SQLAlchemy).

* Мы просим список авторов (1 запрос).
* В цикле для каждого автора просим список его книг.
* Итог: 1 запрос на авторов + N запросов на книги. При 1000 авторах база ляжет.
* *Решение:* Использовать `JOIN` или Eager Loading (`IN (...)`), чтобы вытащить все за 2 запроса.

#### 20. В чем разница между `DELETE` и `TRUNCATE`?

* `DELETE`: Удаляет строки по одной. Пишет каждую удаленную строку в лог транзакций. Работает медленно. Можно откатить.
* `TRUNCATE`: Удаляет (сбрасывает) таблицу целиком на уровне метаданных. Мгновенно. Сбрасывает счетчики ID. Обычно нельзя откатить (в некоторых БД).